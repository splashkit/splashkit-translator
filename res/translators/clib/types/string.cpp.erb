<%#
    Strings from a std::string in the SK code must be allocated on heap and
    freed after use. An example would be:

    1. SK function `Foo' returns a `std::string'
    2. Wrap `std::string' as `__sklib_string'
    3. Return `__sklib_string'
    4. Language `Bar' calls Lib function `Foo' returning the `__sklib_string'
    5. Wrap the returned `__sklib_string''s underlying `char*` in `Bar::String'
    6. Free the returned `__sklib_string' from the heap
    7. Return the wrapped `Bar::String'
%>
typedef struct
{
  char *string;
  int size;
} __sklib_string;
__sklib_string <%= func_prefix %>__to_sklib_string(const std::string &s)
{
    __sklib_string __skreturn;
    __skreturn.size = (int)s.length();
    __skreturn.string = (char *)malloc(__skreturn.size + 1);
    strcpy(__skreturn.string, s.c_str());
    return __skreturn;
}
<%
    # If responsible for freeing allocated heap memory, these functions
    # need to be exposed (i.e., for every vector and every string) --
    # hence mark with extern "C"
    extern_c = 'extern "C" ' if free_heap_allocated?
%>
<%= extern_c %>void <%= func_prefix %>__free__sklib_string(__sklib_string s)
{
<%
    # This call effectively selects which way it should free the heap memory.
    # If it should free heap allocated memory, then it will using free (i.e.,
    # C Library code) otherwise it will call the CLib implementation of the
    # free code (i.e., C++ code).
    unless free_heap_allocated?
%>
    <%= CLib::FUNC_PREFIX %>__free__sklib_string(s);
<%
    else
%>
    free(s.string);
<%
    end # end unless
%>
}
std::string <%= func_prefix %>__to_string(const __sklib_string &s)
{
    std:string result = std::string(s.string);
    <%= func_prefix %>__free__sklib_string(s);
    return result;
}
